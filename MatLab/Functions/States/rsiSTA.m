function [state,ri] = rsiSTA(price,M,thresh,type)
%RSISTA returns a logical STATE for from rsindex.m by The MathWorks, Inc.
% RSISTA returns a logical STATE for from rsindex.m by The MathWorks, Inc.
% which is a value that is above/below an upper/lower threshold intended to locate
% overbought and oversold conditions.  
% M serves as a detrending function
%   NOTE: It is important to consider that an RSI STATE really has 3 states.
%            1      Above upper threshold is overbought
%           -1      Below lower threshold is oversold
%            0      There is also a neutral region between thresholds and 50%
%   
%   This function may also be used as a STATE function, although it would be equally
%   appropriate to call the 'rsindex' function directly.  
%   The output from the function is in a state form.
%
%   [signal,r,sh,ri,ma,thresh] = RSISIG(price,M,thresh,type)
%
%           signal	The generated output SIGNAL (also a STATE)
%           ri      RSI values generated by the call to rsindex.m
%
% Author:           Mark Tompkins
% Revision:			4906.14673
% All rights reserved.

%% MEX code to be skipped
coder.extrinsic('movAvg_mex','OHLCSplitter','rsindex')

%% Defaults and parsing

if numel(thresh) == 1 % scalar value
	thresh = [100-thresh, thresh];
else
    if thresh(1) > thresh(2)
        thresh = thresh(2:-1:1);
    end %if	
end %if

if numel(M) > 1 
	N = M(1);
	if M(2) < 0
        M = 15 * N;
    else
        M = M(2);
	end; % if
else
    % M is the detrend average
    % It would appear we are taking a multiple of M below
    % to capture a longer moving average to detrend
    N = M(1);
    M = 15*M(1);
end
    

% Preallocate so we can MEX
rows = size(price,1);
fClose = zeros(rows,1);                                     %#ok<NASGU>
state = zeros(rows,1);
ri = zeros(rows,1);                                         %#ok<NASGU>

[fClose] = OHLCSplitter(price);

%% Detrend with a moving average
if M == 0
    ma = zeros(length(fClose),1);
else
    ma = movAvg_mex(fClose,M,M,type);
end

ri = rsindex(fClose - ma, N);


%% Generate STATE

% Crossing the lower threshold (oversold)
indx    = ri < thresh(1);
% Unknown Matlab adjuster
% indx    = [false; indx(1:end-1) & ~indx(2:end)];
state(indx) = 1;

% Crossing the upper threshold (overbought)
indx    = ri > thresh(2);
% Unknown Matlab adjuster
% indx    = [false; indx(1:end-1) & ~indx(2:end)];
state(indx) = -1;
