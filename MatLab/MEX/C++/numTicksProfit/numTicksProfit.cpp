// numTicksProfit.cpp : Defines the entry point for the console application.
// http://www.kobashicomputing.com/node/177 for a reference to x64 bit
//
//
// nlhs Number of output variables nargout 
// plhs Array of mxArray pointers to the output variables varargout
// nrhs Number of input variables nargin
// prhs Array of mxArray pointers to the input variables varargin
//
// Matlab MEX function:
// [barsOut,sigOut,sharpeOut] = numTicksProfit(barsIn,sigIn,sharpeIn,minTick,numTicks,openAvg)
// 
// Inputs:
//		barsIn		A 2-D array of prices in the form of Open | High | Low | Close
//		sigIn		An array the same length as barsIn, which gives the quantity bought or sold on a given bar.  Consider Matlab remEchosMEX
//		sharpeIn	Double representing the sharpe ratio adjuster for the given number of bars
//		minTick		Double representing the per contract minimum tick increment
//		numTicks	Double representing the number of ticks for the open position price to take a profit
//		openAvg		One of two ways to handle multiple entries in the open ledger.
//						0	Each trade individually
//						1	Average the open position	(only logically useful when there is more than a 1 lot open position)
//
// Outputs:
//		barsOut		A 2-D array of prices with the addition of any virtual bars where a profit is taken in the form of Open | High | Low | Close
//		sigOut		An array the same length as barsOut which includes any profit taking signals generated by numTicksProfitCPP
//		sharpeOut	A double representing the updated sharpe ratio adjuster including the additional virtual bars if any
//
//	NOTES			We will assume the following standard:	+/- 1 lot is additive	+/- 2 lots is a reverse
//					This is the version that should be used with a SIGNAL input.
//					There is (will be) a version that should be used when a STATE input is supplied to allow for continued reentry
//
// Author: Mark Tompkins

// MATLAB array return sample
/*
		#include <vector>
		#include "mex.h"

		mxArray * getMexArray(const std::vector<double>& v)
		{
			mxArray * mx = mxCreateDoubleMatrix(1,v.size(), mxREAL);
			std::copy(v.begin(), v.end(), mxGetPr(mx));
			return mx;
		}

		void mexFunction(int nlhs, mxArray *plhs[ ], int nrhs, const mxArray *prhs[ ]) 
		{
			std::vector<double> v;

			v.push_back(0);
			v.push_back(1);
			v.push_back(2);
			v.push_back(3);

			plhs[0] = getMexArray(v);

		}
*/


#include "mex.h"
#include <stdio.h>
#include <list>
#include <iterator>

extern "C" mxArray *mxCreateSharedDataCopy(const mxArray *pr);

using namespace std;

/* Add this declaration because it does not exist in the "mex.h" header */
// http://www.mathworks.com/support/solutions/en/data/1-6NU359/index.html


// Typedefs
// Create a struct for open position
typedef struct openEntry
{
	int sigIndex;								//	Array index of signal that created open position
	int qtyOpen;								//	Quantity of created open position
	double openPrice;							//	Entry price of open position
	double profitPrice;							//	Price where position will be closed with a profit
} openEntry;

// Create struct for profit ledger
typedef struct profitEntry
{
	int barIndex;								//	Array index of observation that create the profit taking
	int qtyProfit;								//	Quantity bought or sold at the profit taking price
	double profitPrice;							//	Profit price
} profitEntry;

typedef list<double> myDblList;					//typedef so we can use across all list<double>'s
typedef myDblList::iterator myDblListIter;

// Initialize ledgers for open positions and profits
list<openEntry> openLedger;
list<profitEntry> profitLedger;

// Prototypes
openEntry createOpenLedgerEntry(int ID, int qty, double price);
profitEntry createProfitLedgerEntry(int ID, int qty, double price);

void sameBarProfitCheck(int ID, double qty);
void moveProfitLedger(int ID, int qty, double price);
void moveOpenLedger(int ID, int qty);
void cleanSignal(myDblList &sigList);
void checkMinMax(int ID);
void shrinkProfitLedger();
int sign(int num);

// Macros
#define isReal2DfullDouble(P) (!mxIsComplex(P) && mxGetNumberOfDimensions(P) == 2 && !mxIsSparse(P) && mxIsDouble(P))
#define isRealScalar(P) (isReal2DfullDouble(P) && mxGetNumberOfElements(P) == 1)

// Global Variables
double numTicks;								// Number of ticks (representing $ multiples) in which to take a profit
double minTick;									// What a sigle tick increment is for a given contract
double openAvg;									// Should we manage profit taking on a per contract basis or average the net position (0 = atomic | 1 = average)
double minMax;									// Current minimum | maximum to optimize (minimize) checks
double *barsInPtr;								// Pointer for the price matrix
double *sigInPtr;								// Pointer for the signal array
int openPosition = 0;							// Running net position (based solely on changes to openLedger)
int shiftOpen;									// used for readability 
int shiftHigh;
int shiftLow;
int shiftClose;

void mexFunction(int nlhs, mxArray *plhs[], /* Output variables */
				 int nrhs, const mxArray *prhs[]) /* Input variables */
{
	// There are a number of provided functions for interfacing back to Matlab
	// mexFuncion		The gateway to C.  Required in every C & C++ solution to allow Matlab to call it
	// mexEvalString	Execute Matlab command
	// mexCallMatlab	Call Matlab function (.m or .dll) or script
	// mexPrintf		Print to the Matlab command window
	// mexErrMsgTxt		Issue error message and exit returning control to Matlab
	// mexWarnMsgTxt	Issue warning message
	// mexPrintf("Hello, world!");

	// Check number of inputs
	if (nrhs != 6)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:NumInputs",
		"Number of input arguments is not correct. Aborting.");
	// Check number of output assignments
	if (nlhs != 3)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:NumOutputs",
		"Number of output assignments is not correct. Aborting.");

	// Define constants (#define assigns a variable as either a constant or a macro)
	// Inputs
	#define bars_IN		prhs[0]
	#define sig_IN		prhs[1]
	#define sharpe_IN	prhs[2]
	#define minTick_IN	prhs[3]
	#define numTicks_IN	prhs[4]
	#define openAvg_IN	prhs[5]
	// Outputs
	#define bars_OUT	plhs[0]
	#define sig_OUT		plhs[1]
	#define sharpe_OUT	plhs[2]

	// Init variables
	mwSize rowsPrice, colsPrice, rowsSig, colsSig;
    double  sharpeIn, *barsOutPtr, *sigOutPtr;

	
	// Check type of supplied inputs
	if (!isReal2DfullDouble(bars_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:BadInputType",
		"Input 'barsIn' must be a 2 dimensional full double array of type Open | High | Low | Close. Aborting.");

	if (!isReal2DfullDouble(sig_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:BadInputType",
		"Input 'sigIn' must be a 2 dimensional full double array. Aborting.");

	if (!isRealScalar(sharpe_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:BadInputType",
		"Input 'sharpeIn' must be a single scalar double. Aborting.");

	if (!isRealScalar(minTick_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:BadInputType",
		"Input 'minTick' must be a single scalar double. Aborting.");

	if (!isRealScalar(numTicks_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:BadInputType",
		"Input 'numTicks' must be a single scalar double. Aborting.");

	if (!isRealScalar(openAvg_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:BadInputType",
		"Input 'openAvg_IN' must be a single scalar double. Aborting.");
	
	// Assign variables
	rowsPrice = mxGetM(bars_IN);
	colsPrice = mxGetN(bars_IN);
	rowsSig = mxGetM(sig_IN);
	colsSig = mxGetN(sig_IN);

	//	Assign shift variables
	//	This allows up to properly traverse the mxArray which is in an N x 1 form concatenating all columns
	shiftOpen = 0;							// used for readability 
	shiftHigh = rowsPrice;
	shiftLow = 2 * rowsPrice;
	shiftClose = 3 * rowsPrice;				

	// Additional check of inputs
	if (rowsPrice != rowsSig)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:ArrayMismatch",
		"The number of rows in the price array and the signal array are different. Aborting.");

	if (colsSig > 1)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:ArrayMismatch",
		"Input 'sigIn' must be a single column array. Aborting.");

	if (!isRealScalar(sharpe_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:ScalarMismatch",
		"Input 'sharpeIn' must be a double scalar value. Aborting.");

	if (!isRealScalar(minTick_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:ScalarMismatch",
		"Input 'minTick' must be a double scalar value. Aborting.");

	if (!isRealScalar(numTicks_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:ScalarMismatch",
		"Input 'numTicks' must be a double scalar value. Aborting.");

	if (colsPrice != 4)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:ArrayMismatch",
		"Input 'barsIn' must be a 2 dimensional full double array of type Open | High | Low | Close. Aborting.");

	/* Assign pointers to the input arrays */ 
	barsInPtr =		mxGetPr(bars_IN);
	sigInPtr =		mxGetPr(sig_IN);

	/* Assign scalar values */
	sharpeIn =	mxGetScalar(sharpe_IN);
	minTick =	mxGetScalar(minTick_IN);
	numTicks =	mxGetScalar(numTicks_IN);
	openAvg =	mxGetScalar(openAvg_IN);

	// START //
	// Initialize variables
	int	sigIndex;							// Iterator that will store the index of the referenced signal
	int barIndex;							// Iterator that will store the index of the referenced bar
	int anyTrades = 0;						// Variable that indicates if we have any trades

	// Check that we have at least one signal (at least one trade)
	for (sigIndex=0; sigIndex < rowsSig+1; sigIndex++)					// Remember C++ starts counting at '0'
	{
		if (sigInPtr[sigIndex] !=0)	// See if we have a signal
		{
			anyTrades=1;					// Trade found
			break;							// Exit the for loop
		}
	}	

	// Either return the input if not trades found, or start the check for profit targets reached per open position
	if (anyTrades == 0)						// We have no trades
	{
		// http://www.mathworks.com/support/solutions/en/data/1-6NU359/index.html
		// Return what we were given
		bars_OUT	= mxCreateSharedDataCopy(bars_IN);
		sig_OUT		= mxCreateSharedDataCopy(sig_IN);
		sharpe_OUT	= mxCreateSharedDataCopy(sharpe_OUT);
	}
	else									// We have trades
	{
/////////////
//
// FIRST SIGNAL PROCESSING
//
/////////////	
		// sigIndex = first signal index
		// Check for profit on same observation
		sameBarProfitCheck(sigIndex, sigInPtr[sigIndex]);
		
		if (sigInPtr[sigIndex] == -1)		// Short signal.  Assign minMax to LOW
		{
			minMax = barsInPtr[sigIndex + 1 + shiftLow];
		}
		else if (sigInPtr[sigIndex] == 1)	// Long signal. Assign minMax to HIGH
		{
			minMax = barsInPtr[sigIndex + 1 + shiftHigh];
		}
		else // Error check that shouldn't be necessary
		{
			mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:FirstBarParseError", "We've been given a first trade signal of something other than +/- 1. Aborting.");
		}
// FIRST BAR END

/////////////
//
// ITERATE SECTION
//
/////////////

		// ITERATE REMAINING BARS
		// sigIndex = first signal index
		for (int curBar=sigIndex + 1; curBar < rowsSig+1 + 1; curBar++)
		{
			if (sigInPtr[curBar] == 0)
			{
				// Do we have an openPosition ?
				if (openPosition != 0)
				{
					checkMinMax(curBar);
				}
			}
			else if (abs(sigInPtr[curBar]) == 1)
			{
				if ((sigInPtr[curBar] < 0 && openPosition <= 0) || (sigInPtr[curBar] > 0 && openPosition >= 0))					
				{
					// Signal is additive
					sameBarProfitCheck(curBar, sigInPtr[curBar]);
					checkMinMax(curBar);
				}
				else // Signal is reductive
				{
					openPosition = openPosition + sigInPtr[curBar];
					checkMinMax(curBar);
				}
			}
			//	We will use the following convention:
			//	If openPosition is +/-1 and we are given a +/-2 additive, throw an error.
			//	These should have been cleaned prior to this function.
			//	therefore +/-2 MUST be a reverse
			else if (abs(sigInPtr[curBar]) == 2)
			{
				if ((sigInPtr[curBar] > 0 && openPosition < 0) || (sigInPtr[curBar] < 0 && openPosition > 0))
				{
					if (!openLedger.empty())
					{
						openLedger.clear();
					}
					openPosition = 0;
					sameBarProfitCheck(curBar, (sigInPtr[curBar]/2));	// Half the quantity because if true we record a signal lot P&S
					checkMinMax(curBar);
				}
				else
				{
					//mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:inputSignalError", "A signal was given (+/-2) when there was no openPosition or it was additive. Aborting.");
                    
                    // We were given an reverse when there is no open position.  This will need to be
                    // reviewed when we move to the signal convention of x.5 being a reverse.
                    // For now, we will halve the signal.
                    
                }
			}
			else
			{
				// Signal Input Error
				mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:inputSignalError", "A signal was given that was not of the form (int)[-2 <= SIG >= 2]. Aborting.");
			}
		}
		// Iterations complete
		// List deconstructor
		//openLedger.clear();
		//openLedger.~list();
		//~openLedger();

/////////////
//
// OUTPUT PROCESSING
//
/////////////
		if (!profitLedger.empty())
		{
			shrinkProfitLedger();
			int numNewObsv = profitLedger.size();				// number of new signals and virtual profit bars to add

			// Feedback which can be removed
			mexPrintf("\n\nProcessing %g profit bars.\n\n",numNewObsv);

			/* Create matrices for the return arguments */ 
			// http://www.mathworks.com/help/matlab/matlab_external/c-c-source-mex-files.html
			// http://www.mathworks.com/help/matlab/apiref/mxcreatedoublematrix.html
			mwSize numNewRows = rowsPrice + (mwSize)numNewObsv;

			bars_IN = mxCreateDoubleMatrix(numNewRows, 4, mxREAL);
			sig_IN = mxCreateDoubleMatrix(numNewRows, 1, mxREAL);

			// assign the variables for manipulating the arrays (by pointer reference)
			barsOutPtr = mxGetPr(bars_OUT);
			sigOutPtr = mxGetPr(sig_OUT);

			// Temporary lists
			myDblList signals(numNewRows);
			myDblList vBars(numNewRows*4);

			// List iterators
			myDblListIter signalsIter		= signals.begin();
			myDblListIter vBarsOpenIter		= vBars.begin();
			myDblListIter vBarsHighIter		= vBars.begin();
			myDblListIter vBarsLowIter		= vBars.begin();
			myDblListIter vBarsCloseIter	= vBars.begin();

			// Preposition pointers
			advance(vBarsHighIter, shiftHigh);
			advance(vBarsLowIter, shiftLow);
			advance(vBarsCloseIter, shiftClose);

			// deep copy mxArray --> myDblList
			for (int iter = 0; iter < rowsPrice; iter++)
			{
				// Convert reverses to a fraction so we can identify them later
				if (abs(sigInPtr[iter]) == 2)
				{
					*signalsIter = sign(sigInPtr[iter] * 0.5);
				}
				else
				{
					*signalsIter	=	sigInPtr[iter];
				}
				*vBarsOpenIter	=	barsInPtr[iter + shiftOpen];
				*vBarsHighIter	=	barsInPtr[iter + shiftHigh];
				*vBarsLowIter	=	barsInPtr[iter + shiftLow];
				*vBarsCloseIter =	barsInPtr[iter + shiftClose];

				// Advance iterators
				vBarsOpenIter++;
				vBarsHighIter++;
				vBarsLowIter++;
				vBarsCloseIter++;
			}

			// Inserts based on profitLedger
			list<profitEntry>::iterator pftIter;
			int numAdded = 0;											// Counter to offset adds
			int addIdx = 0;
			int shiftAdd = 0;											

			// Reset pointers
			signalsIter		= signals.begin();
			vBarsOpenIter	= vBars.begin(); 
			vBarsHighIter	= vBars.begin(); advance(vBarsHighIter, shiftHigh);
			vBarsLowIter	= vBars.begin(); advance(vBarsLowIter, shiftLow);
			vBarsCloseIter	= vBars.begin(); advance(vBarsCloseIter, shiftClose);

			// Move price pointer to sync with signal pointer (signal lags price by one bar)
			vBarsOpenIter++;
			vBarsHighIter++;
			vBarsLowIter++;
			vBarsCloseIter++;

			// At this point we should have pointers as
			// signals[0]
			// vBars...[1]

			while (!profitLedger.empty())
			{
				pftIter = profitLedger.begin();

				shiftAdd = pftIter->barIndex - shiftAdd;

				// Advance the pointers to insert location (+1 because list.insert is a 'before' insertion)
				advance(signalsIter, shiftAdd + 1 + numAdded);
				advance(vBarsOpenIter, shiftAdd + 1 + numAdded);
				advance(vBarsHighIter, shiftAdd + 1 + numAdded);
				advance(vBarsLowIter, shiftAdd + 1 + numAdded);
				advance(vBarsCloseIter, shiftAdd + 1 + numAdded);

				signals.insert(signalsIter, pftIter->qtyProfit);
				vBars.insert (vBarsOpenIter,pftIter->profitPrice);
				vBars.insert (vBarsHighIter,pftIter->profitPrice);
				vBars.insert (vBarsLowIter,pftIter->profitPrice);
				vBars.insert (vBarsCloseIter,pftIter->profitPrice);

				++numAdded;

				profitLedger.pop_front();
			}

			cleanSignal(signals);

			// Adjust sharpe ratio output
			// http://www.mathworks.com/help/matlab/apiref/mxcreatedoublescalar.html
			double newSharpe = sharpeIn + (double)numNewObsv;		// cast int to double
			plhs[2] = mxCreateDoubleScalar(newSharpe);
		
			// Assign values to output matrices
			// Check for different array sizes
			if ((signals.size()) != vBars.size())
			{
				mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:arraySizeCheck", "A final check for array size failed prior to assigning outputs. Aborting.");
			}

			// Reset pointer
			vBarsOpenIter	= vBars.begin();
			int outIter = 0;

			for (signalsIter = signals.begin(); signalsIter != signals.end(); signalsIter++)
			{
				barsOutPtr[outIter] = *vBarsOpenIter;
				sigOutPtr[outIter] = *signalsIter;
				outIter++;
			}
		}
		else // return inputs
		{
			// http://www.mathworks.com/support/solutions/en/data/1-6NU359/index.html
			// Return what we were given
		
			bars_OUT = mxCreateSharedDataCopy(bars_IN);
			sig_OUT = mxCreateSharedDataCopy(sig_IN);
			sharpe_OUT = mxCreateSharedDataCopy(sharpe_OUT);
		}
		// Processing all trades complete
	}

	// Destructors
	barsInPtr = NULL;
	sigInPtr = NULL;

	profitLedger.clear();
	profitLedger.~list();

	openLedger.clear();
	openLedger.~list();

	return;
}

/////////////
//
// METHODS
//
/////////////

// Constructor for ledger line item creation
openEntry createOpenLedgerEntry(int ID, int qty, double price)
{
	openEntry OpenLedgerEntry;
	OpenLedgerEntry.sigIndex = ID;
	OpenLedgerEntry.qtyOpen = qty;
	OpenLedgerEntry.openPrice = price;
	if (qty < 0)
	{
		OpenLedgerEntry.profitPrice = price - (minTick * numTicks);
	}
	else
	{
		OpenLedgerEntry.profitPrice = price + (minTick * numTicks);
	}

	return OpenLedgerEntry;
}

profitEntry createProfitLedgerEntry(int ID, int qty, double price)
{
	profitEntry ProfitLedgerEntry;
	ProfitLedgerEntry.barIndex = ID;
	ProfitLedgerEntry.qtyProfit = qty * -1;		// Reverse the given signal to offset position
	ProfitLedgerEntry.profitPrice = price;
	
	return ProfitLedgerEntry;
}

void moveProfitLedger(int ID, int qty, double price)
{
	// We take the price of the next observation for the generated signal
	profitLedger.push_back(createProfitLedgerEntry(ID, qty, price));	
	
	// Should only reduce an openPosition if one exists
	// sameBarProfitCheck may move an entry directly to profitLedger without
	// the value of openPosition being modified
	if (openPosition != 0) 
	{
		openPosition = openPosition - qty;
	}
}

void moveOpenLedger(int ID, int qty)
{
	// We take the price of the next observation for the generated signal
	openLedger.push_back(createOpenLedgerEntry(ID, qty, barsInPtr[ID + 1 + shiftOpen]));
	openPosition = openPosition + qty;
}

void sameBarProfitCheck(int ID, double qty)
{
	// Is there a profit on the bar of the trade? 
		// Short signal - check LOW
		if ((qty < 0) && (barsInPtr[ID + 1 + shiftLow] < barsInPtr[ID + 1 + shiftOpen] - (minTick * numTicks)))
		{
			// We have a profit on the same observation.  Put an entry in the profit ledger
			moveProfitLedger(ID, qty, barsInPtr[ID + 1 + shiftOpen] - (minTick * numTicks));
		}
		// Long signal - check HIGH
		else if ((qty > 0) && (barsInPtr[ID + 1 + shiftHigh] > barsInPtr[ID + 1 + shiftOpen] + (minTick * numTicks)))	
		{
			// We have a profit on the same observation.  Put an entry in the profit ledger
			moveProfitLedger(ID, qty, barsInPtr[ID + 1 + shiftOpen] + (minTick * numTicks));		
		} 
		// Signal is not liquidated.
		else
		{
			// Put trade on openLedger with calculated profit price
			moveOpenLedger(ID, qty);
		}
}

void newMinMax(int ID)
{
	if (openPosition < 0)						// Short.  Update minMax to new lower price
	{
		minMax = barsInPtr[ID + 1 + shiftLow];
	}
	else if (openPosition > 0)					// Long.  Update minMax to new high price
	{
		minMax = barsInPtr[ID + 1 + shiftHigh];
	}
	else
	{
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:newMinMaxError", "A call was made to newMinMax without an existing openPosition.  This is a logical coding error. Aborting.");
	}

	if (!openLedger.empty())
	{
		list<openEntry>::iterator iter;
		for (iter = openLedger.begin(); iter != openLedger.end(); iter++)
		{
			if (openPosition < 0)				// Short. Check minMax <= profitPrice
			{
				if (minMax <= iter->profitPrice)
				{
					if (barsInPtr[ID + 1 + shiftOpen] <= iter->profitPrice)
					{
						// Open satisfies profit threshold
						moveProfitLedger(ID, iter->qtyOpen, barsInPtr[ID + 1 + shiftOpen]);
					}
					else
					{
						moveProfitLedger(ID, iter->qtyOpen, iter->profitPrice);
					}
					openLedger.erase(iter);
				}
			}
			else if (openPosition > 0)		// Long. Check minMax >= profitPrice
			{
				if (minMax >= iter->profitPrice)
				{
					if (barsInPtr[ID + 1 + shiftOpen] >= iter->profitPrice)
					{
						// Open satisfies profit threshold
						moveProfitLedger(ID, iter->qtyOpen, barsInPtr[ID + 1 + shiftOpen]);
					}
					else
					{
						moveProfitLedger(ID, iter->qtyOpen, iter->profitPrice);
					}
					openLedger.erase(iter);
				}
			}
		}
	}
}

void checkMinMax(int ID)
{
	if (openPosition < 0)								// Short.  Check minMax to LOW
	{
		if (barsInPtr[ID + 1 + shiftLow] < minMax)		//New minMax
		{
			newMinMax(ID);
		}
	}
	else if (openPosition > 0)							// Long.  Check minMax to HIGH
	{
		if (barsInPtr[ID + 1 + shiftHigh] > minMax)		//New minMax
		{
			newMinMax(ID);
		}			
	}
}

void shrinkProfitLedger()
{
	list<profitEntry>::iterator iterMain, iterPlusOne;

	iterPlusOne = profitLedger.begin();		// Instantiate look ahead iterator first

	for (iterMain = profitLedger.begin(); iterMain != profitLedger.end(); iterMain++)
	{
		++iterPlusOne;						// Advance the look ahead pointer so it is always iterMain+1;
		//if (iterMain != profitLedger.end())
		//{
			if ((iterMain->barIndex == iterPlusOne->barIndex) &&
				(sign(iterMain->qtyProfit) == sign(iterPlusOne->qtyProfit)))
			{
				iterPlusOne->qtyProfit = iterPlusOne->qtyProfit + iterMain->qtyProfit;
				profitLedger.erase(iterMain);
			}
		//}
	}
}

void cleanSignal(myDblList &sigList)	
{
	int netPosition = 0;

	for (myDblListIter iter = sigList.begin(); iter != sigList.end(); iter++)
	{
		// Fractional signals are reverses that we need to return to a logical value
		if (abs(*iter) == 0.5)
		{
			// Reverse logic error.  Advise and abort.
			if(((netPosition < 0) && (*iter < 0)) || ((netPosition > 0) && (*iter > 0)))
			{
				mexErrMsgIdAndTxt( "MATLAB:numTicksProfitSigCPP:cleanSignal", "Reverse logic encountered in signal array. Aborting.");
			}
			else
			{
				*iter = (netPosition * -1) + (1 * sign(*iter));
			}
		}
		else
		{
			netPosition = netPosition + *iter;
		}
	}
}

// Get sign of signal
int sign(int num)
{
	return num > 0 ? 1 : (num < 0 ? -1 : 0);
}