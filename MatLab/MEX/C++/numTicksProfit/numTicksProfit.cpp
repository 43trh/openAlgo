// numTicksProfit.cpp
//
// nlhs Number of output variables nargout 
// plhs Array of mxArray pointers to the output variables varargout
// nrhs Number of input variables nargin
// prhs Array of mxArray pointers to the input variables varargin
//
// Matlab MEX function:
// [barsOut,sigOut,sharpeOut] = numTicksProfit(barsIn,sigIn,sharpeIn,minTick,numTicks,openAvg)
// 
// Inputs:
//		barsIn		A matrix array of prices in the form of Open | High | Low | Close
//		sigIn		An 1-D array the same length as barsIn, which gives the quantity bought or sold on a given bar.  Consider Matlab remEchosMEX
//		minTick		Double representing the per contract minimum tick increment
//		numTicks	Double representing the number of ticks for the open position price to take a profit
//		openAvg		One of two ways to handle multiple entries in the open ledger.
//						0	Each trade individually
//						1	Average the open position	(only logically useful when there is more than a 1 lot open position)
//
// Outputs:
//		barsOut		A 2-D array of prices with the addition of any virtual bars where a profit is taken in the form of Open | High | Low | Close
//		sigOut		An array the same length as barsOut which includes any profit taking signals generated by numTicksProfitCPP
//
//	NOTES			We will assume the following standard:	+/- 1 lot is additive	+/- 2 lots is a reverse
//					This is the version that should be used with a SIGNAL input.
//					There is (will be) a version that should be used when a STATE input is supplied to allow for continued reentry
//

// MATLAB array return sample
/*
#include <vector>
#include "mex.h"

mxArray * getMexArray(const std::vector<double>& v)
{
mxArray * mx = mxCreateDoubleMatrix(1,v.size(), mxREAL);
std::copy(v.begin(), v.end(), mxGetPr(mx));
return mx;
}

void mexFunction(int nlhs, mxArray *plhs[ ], int nrhs, const mxArray *prhs[ ]) 
{
std::vector<double> v;

v.push_back(0);
v.push_back(1);
v.push_back(2);
v.push_back(3);

plhs[0] = getMexArray(v);

}
*/


#include "mex.h"
#include <list>
#include <iterator>
#include "myMath.h"

// Declare external reference to undocumented C function
#ifdef __cplusplus
extern "C"
{
#endif

	mxArray *mxCreateSharedDataCopy(const mxArray *pr);
	// and any other prototypes for undocumented API functions you are using

#ifdef __cplusplus
}
#endif

using namespace std;

/* Add this declaration because it does not exist in the "mex.h" header */
// http://www.mathworks.com/support/solutions/en/data/1-6NU359/index.html


// Typedefs
// Create a struct for open position
typedef struct openEntry
{
	int sigIndex;								//	Array index of signal that created open position
	int qtyOpen;								//	Quantity of created open position
	double openPrice;							//	Entry price of open position
	double profitPrice;							//	Price where position will be closed with a profit
} openEntry;

// Create struct for profit ledger
typedef struct profitEntry
{
	int barIndex;								//	Array index of observation that create the profit taking
	int qtyProfit;								//	Quantity bought or sold at the profit taking price
	double profitPrice;							//	Profit price
} profitEntry;


// Prototypes
openEntry createOpenLedgerEntry(int ID, int qty, double price);
profitEntry createProfitLedgerEntry(int ID, int qty, double price);

bool isTrade(double isSig);
bool knownAdvSig(double advSig);
int sumQty(const list<openEntry> &theList);
double getAvgPftPrice(const list<openEntry> &openLedger);
void shrinkProfitLedger(list<profitEntry> &profitLedger);
//void moveOpenLedger(list<openEntry> &openLedger, const int ID, int qty, int &openPosition);
void moveProfitLedger(list<profitEntry> &profitLedger, const int ID, int qty, double price);
void checkOpen(list<openEntry> &openLedger, list<profitEntry> &profitLedger, const int ID, int &openPosition);
void newAvgChk(list<openEntry> &openLedger, list<profitEntry> &profitLedger, const int ID, int &openPosition, double &minMax);
void newMinMax(list<openEntry> &openLedger,  list<profitEntry> &profitLedger, const int ID, int &openPosition, double &minMax);
void checkMinMax(list<openEntry> &openLedger, list<profitEntry> &profitLedger, const int ID, int &openPosition, double &minMax);
void chkOpenMethod(int &openPosition, const int curBar, double &minMax, list<openEntry> &openLedger, list<profitEntry> &profitLedger);
void sameBarProfitCheck(list<openEntry> &openLedger, list<profitEntry> &profitLedger, const int ID, int qty, int &openPosition, double &minMax);

// Macros
#define isReal2DfullDouble(P) (!mxIsComplex(P) && mxGetNumberOfDimensions(P) == 2 && !mxIsSparse(P) && mxIsDouble(P))
#define isRealScalar(P) (isReal2DfullDouble(P) && mxGetNumberOfElements(P) == 1)

// Global Variables
double PROFIT_TGT;								// Calculated profit target (for readability)
double numTicks;								// Number of ticks (representing $ multiples) in which to take a profit
double minTick;									// What a single tick increment is for a given contract
double openAvg;									// Should we manage profit taking on a per contract basis or average the net position (0 = atomic | 1 = average)

double *barsInPtr;								// Pointer for the price matrix
double *sigInPtr;								// Pointer for the signal array
int shiftOpen;									// used for readability 
int shiftHigh;
int shiftLow;
int shiftClose;



void mexFunction(int nlhs, mxArray *plhs[], /* Output variables */
				 int nrhs, const mxArray *prhs[]) /* Input variables */
{
	// There are a number of provided functions for interfacing back to Matlab
	// mexFuncion		The gateway to C.  Required in every C & C++ solution to allow Matlab to call it
	// mexEvalString	Execute Matlab command
	// mexCallMatlab	Call Matlab function (.m or .dll) or script
	// mexPrintf		Print to the Matlab command window
	// mexErrMsgTxt		Issue error message and exit returning control to Matlab
	// mexWarnMsgTxt	Issue warning message
	// mexPrintf("Hello, world!");

	// Check number of inputs
	if (nrhs != 5)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:NumInputs",
		"Number of input arguments is not correct. Aborting.");
	// Check number of output assignments
	if (nlhs != 2)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:NumOutputs",
		"Number of output assignments is not correct. Aborting.");

	// Define constants (#define assigns a variable as either a constant or a macro)
	// Inputs
#define bars_IN		prhs[0]
#define sig_IN		prhs[1]
#define minTick_IN	prhs[2]
#define numTicks_IN	prhs[3]
#define openAvg_IN	prhs[4]
	// Outputs
#define bars_OUT	plhs[0]
#define sig_OUT		plhs[1]

	// Init variables
	mwSize rowsPrice, colsPrice, rowsSig, colsSig;
	double  *barsOutPtr, *sigOutPtr;


	// Check type of supplied inputs
	if (!isReal2DfullDouble(bars_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:BadInputType",
		"Input 'barsIn' must be a 2 dimensional full double array of type Open | High | Low | Close. Aborting.");

	if (!isReal2DfullDouble(sig_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:BadInputType",
		"Input 'sigIn' must be a 2 dimensional full double array. Aborting.");

	if (!isRealScalar(minTick_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:BadInputType",
		"Input 'minTick' must be a single scalar double. Aborting.");

	if (!isRealScalar(numTicks_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:BadInputType",
		"Input 'numTicks' must be a single scalar double. Aborting.");

	if (!isRealScalar(openAvg_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:BadInputType",
		"Input 'openAvg_IN' must be a single scalar double. Aborting.");

	// Assign variables
	rowsPrice = mxGetM(bars_IN);
	colsPrice = mxGetN(bars_IN);
	rowsSig = mxGetM(sig_IN);
	colsSig = mxGetN(sig_IN);
	const double mxLINEAR_SIZE = rowsPrice * colsPrice;					// mxArray is passed as a continuous 1 dimensional array

	//	Assign shift variables
	//	This allows up to properly traverse the mxArray which is in an N x 1 form concatenating all columns
	shiftOpen = 0;							// used for readability 
	shiftHigh = rowsPrice;
	shiftLow = 2 * rowsPrice;
	shiftClose = 3 * rowsPrice;				

	// Additional check of inputs
	if (rowsPrice != rowsSig)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ArrayMismatch",
		"The number of rows in the price array and the signal array are different. Aborting.");

	if (colsSig > 1)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ArrayMismatch",
		"Input 'sigIn' must be a single column array. Aborting.");

	if (!isRealScalar(minTick_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ScalarMismatch",
		"Input 'minTick' must be a double scalar value. Aborting.");

	if (!isRealScalar(numTicks_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ScalarMismatch",
		"Input 'numTicks' must be a double scalar value. Aborting.");

	if (colsPrice != 4)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ArrayMismatch",
		"Input 'barsIn' must be a 2 dimensional full double array of type Open | High | Low | Close. Aborting.");

	/* Assign pointers to the input arrays */ 
	barsInPtr =		mxGetPr(bars_IN);
	sigInPtr =		mxGetPr(sig_IN);

	/* Assign scalar values */
	minTick =	mxGetScalar(minTick_IN);
	numTicks =	mxGetScalar(numTicks_IN);
	openAvg =	mxGetScalar(openAvg_IN);

	// Final check of inputs
	if ((openAvg != 0) && (openAvg != 1))
	{
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ProfitTargetCalc",
			"Input 'openAvg' must be either 0 - atomic price | 1 - average price. \nInput was given as %d. Aborting.", openAvg);
	}
	
	if (minTick < 0)
	{
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:minTickError",
			"Input 'minTick' must be an integer greater than or equal to zero. \nInput was given as %d. Aborting.", minTick);
	}

	PROFIT_TGT = (minTick * numTicks);

	// START //
	// Initialize variables
	int	sigIndex;							// Iterator that will store the index of the referenced signal
	bool anyTrades = false;					// Trade logical

	// Check that we have at least one signal (at least one trade)
	for (sigIndex=0; sigIndex < int(rowsSig); sigIndex++)					// Remember C++ starts counting at '0'
	{
		if (isTrade(sigInPtr[sigIndex]))	// See if we have a signal
		{
			anyTrades = true;
			break;							// Exit the for loop
		}
	}	

	// If there are no trades or the minTick is zero indicating no profit taking then return the original input.
	// Otherwise start the check for profit targets reached per open position
	// We have no trades
	if (!anyTrades || minTick == 0)						
	{
		// http://www.mathworks.com/support/solutions/en/data/1-6NU359/index.html
		// Return what we were given
		bars_OUT	= mxCreateSharedDataCopy(bars_IN);
		sig_OUT		= mxCreateSharedDataCopy(sig_IN);
	}
	// We have trades
	else									
	{
		double minMax;									// Current minimum | maximum to optimize (minimize) checks

		/////////////
		//
		// FIRST SIGNAL PROCESSING
		//
		/////////////	
		
		// Initialize ledgers for open positions and profits
		list<openEntry> openLedger;
		list<profitEntry> profitLedger;

		// Put first detected trade on openLedger
		openLedger.push_back(createOpenLedgerEntry(sigIndex, int(sigInPtr[sigIndex]), barsInPtr[sigIndex + 1 + shiftOpen]));

		// Short signal.  Assign minMax to LOW
		if (sigInPtr[sigIndex] < 0)		
		{
			minMax = barsInPtr[sigIndex + 1 + shiftLow];
		}
		// Long signal. Assign minMax to HIGH
		else if (sigInPtr[sigIndex] > 0)	
		{
			minMax = barsInPtr[sigIndex + 1 + shiftHigh];
		}

		// Check for profit on same observation
		// 'minMax' has been updated so we can safely call 'sameBarProfitCheck'
		int openPosition = int(sigInPtr[sigIndex]);
		sameBarProfitCheck(openLedger, profitLedger, sigIndex, int(sigInPtr[sigIndex]), openPosition, minMax);

		// FIRST BAR END

		/////////////
		//
		// ITERATE SECTION
		//
		/////////////

		// ITERATE REMAINING BARS
		// sigIndex = first signal index
		for (int curBar=sigIndex + 1; curBar < int(rowsSig)-1; curBar++)
		{

		// ORDER OF SIGNIFICANCE from a signal with an existing position
			// REVERSE
			if (fraction(sigInPtr[curBar]))
			{
				// Is fraction the same sign (additive in nature) ?
				// Additive
				if (sign(sigInPtr[curBar] == sign(openPosition)))
				{
					// Nothing to do with the current logic
					// The only fraction currently in use is |0.5| to liquidate entire opposing openPosition
				}
				// Reductive (liquidate)
				else
				{
					// Adding logic here for prevention of 'other' fractions or surprising inputs
					if (knownAdvSig(sigInPtr[curBar]))
					{
						// Liquidate any open position
						openLedger.clear();
						openPosition = 0;
					}
					// Unknown advanced instruction
					else
					{
						mexErrMsgIdAndTxt( "MATLAB:AdvancedSignal:fractionUnknown",
							"A signal contained an advanced fractional instruction that we could not interpret. Aborting.");
					}
				}
			}

			// REDUCE or ADD
			// Do we have a signal with an integer portion ?
			if (abs(int(sigInPtr[curBar])) >= 1)
			{
				// Signal is reductive
				if ((int(sigInPtr[curBar]) > 0 && openPosition < 0) || (int(sigInPtr[curBar]) < 0 && openPosition > 0))					
				{
					// Signal is effectively a reverse or liquidate
					if (int(sigInPtr[curBar]) >= openPosition)
					{
						openPosition = int(sigInPtr[curBar]) + openPosition;
						openLedger.clear();
						if (openPosition != 0)
						{
							openLedger.push_back(createOpenLedgerEntry(curBar, openPosition, barsInPtr[curBar + 1 + shiftOpen]));
						}
					}
					else
					{
						// How many do we need to reduce by?
						int needQty = int(sigInPtr[curBar]);
						// Prepare to iterate until we are satisfied
						while (needQty !=0)
						{
							// Is the current line item quantity larger than what we need?
							if (abs(openLedger.front().qtyOpen) > needQty)
							{
								// Reduce the position size.  We are aggregating so we add (e.g. 5 Purchases + 4 Sales = 1 Long)
								openLedger.front().qtyOpen = openLedger.front().qtyOpen + needQty;
								// We are satisfied and don't need any more contracts
								needQty = 0;
							}
							// Current line item quantity is equal to or smaller than what we need.  Process P&L and remove.
							else
							{
								// Reduce needed quantity by what we've been provided
								needQty = needQty + openLedger.front().qtyOpen;
								// Remove the line item (FIFO)
								openLedger.pop_front();
							}
						}
						openPosition = openPosition + int(sigInPtr[curBar]);
					}
				}
				// Signal is additive
				else
				{
					// Before adding, check if the open qualifies to liquidate any existing position
					if (openPosition != 0)
					{
						chkOpenMethod(openPosition, curBar, minMax, openLedger, profitLedger);
					}
					
					// Process addition
					// Put trade on openLedger
					openLedger.push_back(createOpenLedgerEntry(curBar, int(sigInPtr[curBar]), barsInPtr[curBar + 1 + shiftOpen]));
					openPosition = openPosition + int(sigInPtr[curBar]);
					sameBarProfitCheck(openLedger, profitLedger, curBar, int(sigInPtr[curBar]), openPosition, minMax);
				}
			}
			// NONE
			else
			{
				// We can just check against the open and leave the range check for all entries on the openLedger below
				// Only check if necessary
				if (openPosition !=0)
				{
					chkOpenMethod(openPosition, curBar, minMax, openLedger, profitLedger);
				}
				
			}

			// Check for extremes that result in a profit for any openPosition
			if (openPosition != 0)
			{
				checkMinMax(openLedger, profitLedger, curBar, openPosition, minMax);
			}
		}

		/////////////
		//
		// OUTPUT PROCESSING
		//
		/////////////
		if (!profitLedger.empty())
		{
			shrinkProfitLedger(profitLedger);
			int numNewObsv = profitLedger.size();				// number of new signals and virtual profit bars to add

			/* Create matrices for the return arguments */ 
			// http://www.mathworks.com/help/matlab/matlab_external/c-c-source-mex-files.html
			// http://www.mathworks.com/help/matlab/apiref/mxcreatedoublematrix.html
			mwSize numNewRows = rowsPrice + (mwSize)numNewObsv;

			bars_OUT = mxCreateDoubleMatrix(numNewRows, 4, mxREAL);
			sig_OUT = mxCreateDoubleMatrix(numNewRows, 1, mxREAL);

			// assign the variables for manipulating the arrays (by pointer reference)
			barsOutPtr = mxGetPr(bars_OUT);
			sigOutPtr = mxGetPr(sig_OUT);

			// Temporary lists
			list<double> signals;
			list<double> vBars;

			// List iterators
			list<double>::const_iterator signalsIter		= signals.begin();
			list<double>::const_iterator vBarsIter			= vBars.begin();
			list<double>::const_iterator vBarsOpenIter		= vBars.begin();
			list<double>::const_iterator vBarsHighIter		= vBars.begin();
			list<double>::const_iterator vBarsLowIter		= vBars.begin();
			list<double>::const_iterator vBarsCloseIter		= vBars.begin();

			// Preposition pointers
			advance(vBarsHighIter, shiftHigh);
			advance(vBarsLowIter, shiftLow);
			advance(vBarsCloseIter, shiftClose);

			// deep copy mxArray --> myDblList
			for (int iter = 0; iter < mxLINEAR_SIZE; iter++)
			{
				vBars.push_back(barsInPtr[iter]);
			}

			for (int iter = 0; iter < int(rowsSig); iter++)
			{
				signals.push_back(sigInPtr[iter]);
			}

			// Inserts based on profitLedger
			list<profitEntry>::iterator pftIter;
			int shiftAdd = 0;
			int lastLoc = 0;

			// Reset pointers
			signalsIter		= signals.begin();
			vBarsOpenIter	= vBars.begin();
			vBarsHighIter	= vBars.begin();
			vBarsLowIter	= vBars.begin();
			vBarsCloseIter	= vBars.begin();

			advance(vBarsHighIter, shiftHigh);
			advance(vBarsLowIter, shiftLow);
			advance(vBarsCloseIter, shiftClose);

			// Move price pointer to sync with signal pointer (signal lags price by one bar)
			vBarsOpenIter++;
			vBarsHighIter++;
			vBarsLowIter++;
			vBarsCloseIter++;

			// At this point we should have pointers as
			// signals[0]
			// vBarsOpenIter[1]
			// vBarsHighIter[1 + shiftHigh] ...

			// Because we insert before the current index we move all pointers 'in front' of the insertion point
			signalsIter++;
			vBarsOpenIter++;
			vBarsHighIter++;
			vBarsLowIter++;
			vBarsCloseIter++;

			while (!profitLedger.empty())
			{
				pftIter = profitLedger.begin();

				shiftAdd = pftIter->barIndex - lastLoc;

				// Advance the pointers to insert location
				advance(signalsIter, shiftAdd);
				advance(vBarsOpenIter, shiftAdd);
				advance(vBarsHighIter, shiftAdd);
				advance(vBarsLowIter, shiftAdd);
				advance(vBarsCloseIter, shiftAdd);

				signals.insert(signalsIter, pftIter->qtyProfit);
				vBars.insert (vBarsOpenIter,pftIter->profitPrice);
				vBars.insert (vBarsHighIter,pftIter->profitPrice);
				vBars.insert (vBarsLowIter,pftIter->profitPrice);
				vBars.insert (vBarsCloseIter,pftIter->profitPrice);

				lastLoc = pftIter->barIndex;

				profitLedger.pop_front();
			}

			// Reset pointer
			int outIter = 0;

			for (vBarsIter	= vBars.begin(); vBarsIter != vBars.end(); vBarsIter++)
			{
				barsOutPtr[outIter] = *vBarsIter;
				outIter++;
			}

			// Reset index
			outIter = 0;
			for (signalsIter = signals.begin(); signalsIter != signals.end(); signalsIter++)
			{
				sigOutPtr[outIter] = *signalsIter;
				outIter++;
			}
		}
		else // return inputs
		{
			// http://www.mathworks.com/support/solutions/en/data/1-6NU359/index.html
			// Return what we were given

			bars_OUT = mxCreateSharedDataCopy(bars_IN);
			sig_OUT = mxCreateSharedDataCopy(sig_IN);
		}
		
	}

	return;
}

/////////////
//
// FUNCTIONS & METHODS
//
/////////////

// Constructor for ledger line item creation
openEntry createOpenLedgerEntry(int ID, int qty, double price)
{
	openEntry OpenLedgerEntry;
	OpenLedgerEntry.sigIndex = ID;
	OpenLedgerEntry.qtyOpen = qty;
	OpenLedgerEntry.openPrice = price;
	if (qty < 0)
	{
		OpenLedgerEntry.profitPrice = price - (minTick * numTicks);
	}
	else
	{
		OpenLedgerEntry.profitPrice = price + (minTick * numTicks);
	}

	return OpenLedgerEntry;
}

profitEntry createProfitLedgerEntry(int ID, int qty, double price)
{
	profitEntry ProfitLedgerEntry;
	ProfitLedgerEntry.barIndex = ID;
	ProfitLedgerEntry.qtyProfit = qty;												// Quantity already transformed at calling function
	ProfitLedgerEntry.profitPrice = price;

	return ProfitLedgerEntry;
}

void moveProfitLedger(list<profitEntry> &profitLedger, const int ID, int qty, double price)
{
	// We take the price of the next observation for the generated signal
	// We reverse the quantity to reflect closing of the positions
	profitLedger.push_back(createProfitLedgerEntry(ID, qty * -1, price));	
}

void sameBarProfitCheck(list<openEntry> &openLedger, list<profitEntry> &profitLedger, const int ID, int qty, int &openPosition, double &minMax)
{
	if (openAvg == 0)
	{
		// Is there a profit on the bar of the trade? 
		// Short signal - check LOW
		if ((qty < 0) && (barsInPtr[ID + 1 + shiftLow] < barsInPtr[ID + 1 + shiftOpen] - PROFIT_TGT))
		{
			// We have a profit on the same observation.  Move the entry in the profit ledger
			moveProfitLedger(profitLedger, ID, qty, barsInPtr[ID + 1 + shiftOpen] - PROFIT_TGT);
			openPosition = openPosition - qty;
			openLedger.pop_back();
		}
		// Long signal - check HIGH
		else if ((qty > 0) && (barsInPtr[ID + 1 + shiftHigh] > barsInPtr[ID + 1 + shiftOpen] + PROFIT_TGT))	
		{
			// We have a profit on the same observation.  Put entry in the profit ledger
			moveProfitLedger(profitLedger, ID, qty, barsInPtr[ID + 1 + shiftOpen] + PROFIT_TGT);
			openPosition = openPosition - qty;
			openLedger.pop_back();
		} 
		else
		{
			openPosition = openPosition + qty;
		}
	}
	else
	{

		// Check same bar using new average
		// Requires minMax already updated !!
		newAvgChk(openLedger, profitLedger, ID, openPosition, minMax);

	}
}

// A new High | Low has occurred and we have determined that we have an openPosition
// Check if profit targets have been reached
void newMinMax(list<openEntry> &openLedger,  list<profitEntry> &profitLedger, const int ID, int &openPosition, double &minMax)
{
	if (!openLedger.empty())
	{
		if (openAvg == 0)
		{
			list<openEntry>::iterator iter;
			for (iter = openLedger.begin(); iter != openLedger.end(); iter++)
			{
				// Short. Check minMax <= profitPrice
				if (openPosition < 0)				
				{
					if (minMax <= iter->profitPrice)
					{
						moveProfitLedger(profitLedger, ID, iter->qtyOpen, iter->profitPrice);
						openLedger.erase(iter);
					}
				}
				// Long. Check minMax >= profitPrice
				else if (openPosition > 0)		
				{
					if (minMax >= iter->profitPrice)
					{
						moveProfitLedger(profitLedger, ID, iter->qtyOpen, iter->profitPrice);
						openLedger.erase(iter);
					}
				}
			}
			openPosition = sumQty(openLedger);
		}
		// Using the average price approach 
		else
		{
			newAvgChk(openLedger, profitLedger, ID, openPosition, minMax);
		}
	}
}

void newAvgChk(list<openEntry> &openLedger, list<profitEntry> &profitLedger, const int ID, int &openPosition, double &minMax)
{
	double profitPrice = getAvgPftPrice(openLedger);

	if (openPosition < 0)				// Short. Check minMax <= profitPrice
	{
		if (minMax <= profitPrice)
		{
			while (!openLedger.empty())
			{
				moveProfitLedger(profitLedger, openLedger.front().sigIndex, openLedger.front().qtyOpen, profitPrice);
				profitLedger.pop_front();
			}
			openPosition = 0;
		}
	}
	else if (openPosition > 0)			// Long. Check minMax >= profitPrice
	{
		if (minMax >= profitPrice)
		{
			while (!openLedger.empty())
			{
				moveProfitLedger(profitLedger, openLedger.front().sigIndex, openLedger.front().qtyOpen, profitPrice);
				profitLedger.pop_front();
			}
			openPosition = 0;
		}
	}
}

double getAvgPftPrice(const list<openEntry> &openLedger)
{
	int netQty = 0;
	double wghtPrices = 0;
	double sumWghts = 0;
	double wghtAvg = 0;
	double profitPrice = 0;


	list<openEntry>::const_iterator iter;
	for (iter = openLedger.begin(); iter != openLedger.end(); iter++)
	{
		netQty = netQty + iter->qtyOpen;
		sumWghts = sumWghts + (abs(iter->qtyOpen) * iter->openPrice);
	}

	wghtAvg = sumWghts / abs(netQty);

	// Short objective
	if (netQty < 0)
	{
		profitPrice = wghtAvg - PROFIT_TGT;
	}
	// Long objective
	else
	{
		profitPrice = wghtAvg + PROFIT_TGT;
	}

	return profitPrice;
}

void checkOpen(list<openEntry> &openLedger, list<profitEntry> &profitLedger, const int ID, int &openPosition)
{
	if (openAvg == 0)
	{
		for (list<openEntry>::iterator iter = openLedger.begin(); iter != openLedger.end(); iter++)
		{
			// Short
			if (openPosition < 0)
			{
				if (barsInPtr[ID + 1 + shiftOpen] <= iter->profitPrice)
				{
					// Open satisfies profit threshold
					moveProfitLedger(profitLedger, ID, iter->qtyOpen, barsInPtr[ID + 1 + shiftOpen]);
					openLedger.erase(iter);
					openPosition = sumQty(openLedger);
				}
			}
			// Long
			else
			{
				if (barsInPtr[ID + 1 + shiftOpen] >= iter->profitPrice)
				{
					// Open satisfies profit threshold
					moveProfitLedger(profitLedger, ID, iter->qtyOpen, barsInPtr[ID + 1 + shiftOpen]);
					openLedger.erase(iter);
					openPosition = sumQty(openLedger);
				}
			}
		}
	}
	else
	{
		double profitPrice = getAvgPftPrice(openLedger);

		if (openPosition < 0)
		{
			if (barsInPtr[ID + 1 + shiftOpen] <= profitPrice)
			{
				// Open satisfies profit threshold
				while (!openLedger.empty())
				{
					moveProfitLedger(profitLedger, openLedger.front().sigIndex, openLedger.front().qtyOpen, barsInPtr[ID + 1 + shiftOpen]);
					profitLedger.pop_front();
				}
				openPosition = 0;
			}
		}
		else
		{
			if (barsInPtr[ID + 1 + shiftOpen] >= profitPrice)
			{
				// Open satisfies profit threshold
				while (!openLedger.empty())
				{
					moveProfitLedger(profitLedger, openLedger.front().sigIndex, openLedger.front().qtyOpen, barsInPtr[ID + 1 + shiftOpen]);
					profitLedger.pop_front();
				}
			}
			openPosition = 0;
		}
	}
};

void checkMinMax(list<openEntry> &openLedger, list<profitEntry> &profitLedger, const int ID, int &openPosition, double &minMax)
{
	if (openPosition < 0)								// Short.  Check minMax to LOW
	{
		if (barsInPtr[ID + 1 + shiftLow] < minMax)		//New minMax
		{
			minMax = barsInPtr[ID + 1 + shiftLow];
			newMinMax(openLedger, profitLedger, ID, openPosition, minMax);
		}
	}
	else if (openPosition > 0)							// Long.  Check minMax to HIGH
	{
		if (barsInPtr[ID + 1 + shiftHigh] > minMax)		//New minMax
		{
			minMax = barsInPtr[ID + 1 + shiftHigh];
			newMinMax(openLedger, profitLedger, ID, openPosition, minMax);
		}			
	}
}

void shrinkProfitLedger(list<profitEntry> &profitLedger)
{
	list<profitEntry>::iterator iterMain, iterPlusOne;

	iterPlusOne = profitLedger.begin();		// Instantiate look ahead iterator first

	for (iterMain = profitLedger.begin(); iterMain != profitLedger.end(); iterMain++)
	{
		++iterPlusOne;						// Advance the look ahead pointer so it is always iterMain+1;
		if ((iterMain->barIndex == iterPlusOne->barIndex) &&
			(sign(iterMain->qtyProfit) == sign(iterPlusOne->qtyProfit)))
		{
			iterPlusOne->qtyProfit = iterPlusOne->qtyProfit + iterMain->qtyProfit;
			profitLedger.erase(iterMain);
		}
	}
}

bool isTrade(double isSig)
{
	if (abs(isSig)>=1)
	{
		return true;
	}
	return false;
}

bool knownAdvSig(double advSig)
{
	// We can check for known advanced signals to help in debugging
	// by registering them here.  This can be a searchable array when
	// more than one advanced signal exists.
	// For now we only need to check for |0.5|

	double frac = abs(advSig - int(advSig));

	if (frac == 0.5)		// Close any opposing open position
	{
		return true;
	}
	return false;
}

// Method to sum the quantity values in any struct of type tradeEntry
int sumQty(const list<openEntry>& theList)
{
	int sumOfQty = 0;  // the sum is accumulated here
	// for (int i=0; i<x.size(); i++)
	for (list<openEntry>::const_iterator it=theList.begin(); it!=theList.end(); it++)
	{
		sumOfQty += it->qtyOpen;
	}

	return sumOfQty;
}

void chkOpenMethod(int &openPosition, const int curBar, double &minMax, list<openEntry> &openLedger, list<profitEntry> &profitLedger )
{
	if (openPosition < 0)
	{
		// We can add a check to reduce calls to the function unless necessary
		if(barsInPtr[curBar + 1 + shiftOpen] < minMax)
		{
			checkOpen(openLedger, profitLedger, curBar, openPosition);
			minMax = barsInPtr[curBar + 1 + shiftOpen];
		}
	}
	else if (openPosition > 0)
	{
		if(barsInPtr[curBar + 1 + shiftOpen] > minMax)
		{
			checkOpen(openLedger, profitLedger, curBar, openPosition);
			minMax = barsInPtr[curBar + 1 + shiftOpen];
		}
	}	
}

//
//  -------------------------------------------------------------------------
//                                  _    _ 
//         ___  _ __   ___ _ __    / \  | | __ _  ___   ___  _ __ __ _ 
//        / _ \| '_ \ / _ \ '_ \  / _ \ | |/ _` |/ _ \ / _ \| '__/ _` |
//       | (_) | |_) |  __/ | | |/ ___ \| | (_| | (_) | (_) | | | (_| |
//        \___/| .__/ \___|_| |_/_/   \_\_|\__, |\___(_)___/|_|  \__, |
//             |_|                         |___/                 |___/
//  -------------------------------------------------------------------------
//        This code is distributed in the hope that it will be useful,
//
//                      	   WITHOUT ANY WARRANTY
//
//                  WITHOUT CLAIM AS TO MERCHANTABILITY
//
//                  OR FITNESS FOR A PARTICULAR PURPOSE
//
//                          expressed or implied.
//
//   Use of this code, pseudocode, algorithmic or trading logic contained
//   herein, whether sound or faulty for any purpose is the sole
//   responsibility of the USER. Any such use of these algorithms, coding
//   logic or concepts in whole or in part carry no covenant of correctness
//   or recommended usage from the AUTHOR or any of the possible
//   contributors listed or unlisted, known or unknown.
//
//   Any reference of this code or to this code including any variants from
//   this code, or any other credits due this AUTHOR from this code shall be
//   clearly and unambiguously cited and evident during any use, whether in
//   whole or in part.
//
//   The public sharing of this code does not relinquish, reduce, restrict or
//   encumber any rights the AUTHOR has in respect to claims of intellectual
//   property.
//
//   IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY
//   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
//   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//   ANY WAY OUT OF THE USE OF THIS SOFTWARE, CODE, OR CODE FRAGMENT(S), EVEN
//   IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//   -------------------------------------------------------------------------
//
//                             ALL RIGHTS RESERVED
//
//   -------------------------------------------------------------------------
//
//   Author:	Mark Tompkins
//   Revision:	4929.25227
//   Copyright:	(c)2013
//