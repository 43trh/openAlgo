// numTicksProfit.cpp
//
// nlhs Number of output variables nargout 
// plhs Array of mxArray pointers to the output variables varargout
// nrhs Number of input variables nargin
// prhs Array of mxArray pointers to the input variables varargin
//
// Matlab MEX function:
// [barsOut,sigOut,sharpeOut] = numTicksProfit(barsIn,sigIn,sharpeIn,minTick,numTicks,openAvg)
// 
// Inputs:
//		barsIn		A matrix array of prices in the form of Open | High | Low | Close
//		sigIn		An 1-D array the same length as barsIn, which gives the quantity bought or sold on a given bar.  Consider Matlab remEchosMEX
//		minTick		Double representing the per contract minimum tick increment
//		numTicks	Double representing the number of ticks for the open position price to take a profit
//		openAvg		One of two ways to handle multiple entries in the open ledger.
//						0	Each trade individually
//						1	Average the open position	(only logically useful when there is more than a 1 lot open position)
//
// Outputs:
//		barsOut		A 2-D array of prices with the addition of any virtual bars where a profit is taken in the form of Open | High | Low | Close
//		sigOut		An array the same length as barsOut which includes any profit taking signals generated by numTicksProfitCPP
//
//	NOTES			We will assume the following standard:	+/- 1 lot is additive	+/- 2 lots is a reverse
//					This is the version that should be used with a SIGNAL input.
//					There is (will be) a version that should be used when a STATE input is supplied to allow for continued reentry
//

// MATLAB array return sample
/*
#include <vector>
#include "mex.h"

mxArray * getMexArray(const std::vector<double>& v)
{
mxArray * mx = mxCreateDoubleMatrix(1,v.size(), mxREAL);
std::copy(v.begin(), v.end(), mxGetPr(mx));
return mx;
}

void mexFunction(int nlhs, mxArray *plhs[ ], int nrhs, const mxArray *prhs[ ]) 
{
std::vector<double> v;

v.push_back(0);
v.push_back(1);
v.push_back(2);
v.push_back(3);

plhs[0] = getMexArray(v);

}
*/


#include "mex.h"
#include <stdio.h>
#include <list>
#include <iterator>

// Declare external reference to undocumented C function
#ifdef __cplusplus
extern "C"
{
#endif

	mxArray *mxCreateSharedDataCopy(const mxArray *pr);
	// and any other prototypes for undocumented API functions you are using

#ifdef __cplusplus
}
#endif

using namespace std;

/* Add this declaration because it does not exist in the "mex.h" header */
// http://www.mathworks.com/support/solutions/en/data/1-6NU359/index.html


// Typedefs
// Create a struct for open position
typedef struct openEntry
{
	int sigIndex;								//	Array index of signal that created open position
	int qtyOpen;								//	Quantity of created open position
	double openPrice;							//	Entry price of open position
	double profitPrice;							//	Price where position will be closed with a profit
} openEntry;

// Create struct for profit ledger
typedef struct profitEntry
{
	int barIndex;								//	Array index of observation that create the profit taking
	int qtyProfit;								//	Quantity bought or sold at the profit taking price
	double profitPrice;							//	Profit price
} profitEntry;

// Initialize ledgers for open positions and profits
list<openEntry> openLedger;
list<profitEntry> profitLedger;

// Prototypes
openEntry createOpenLedgerEntry(int ID, int qty, double price);
profitEntry createProfitLedgerEntry(int ID, int qty, double price);

void sameBarProfitCheck(int ID, int qty);
void moveProfitLedger(int ID, int qty, double price);
void moveOpenLedger(int ID, int qty);
void checkMinMax(int ID);
void newMinMax(int ID);
void shrinkProfitLedger();
void newAvgChk(int ID);

bool fraction(double num);

double sign(double num);
double getAvgPftPrice();

// Macros
#define isReal2DfullDouble(P) (!mxIsComplex(P) && mxGetNumberOfDimensions(P) == 2 && !mxIsSparse(P) && mxIsDouble(P))
#define isRealScalar(P) (isReal2DfullDouble(P) && mxGetNumberOfElements(P) == 1)

// Global Variables
double PROFIT_TGT;								// Calculated profit target (for readability)
double numTicks;								// Number of ticks (representing $ multiples) in which to take a profit
double minTick;									// What a sigle tick increment is for a given contract
double openAvg;									// Should we manage profit taking on a per contract basis or average the net position (0 = atomic | 1 = average)
double minMax;									// Current minimum | maximum to optimize (minimize) checks
double *barsInPtr;								// Pointer for the price matrix
double *sigInPtr;								// Pointer for the signal array
int openPosition = 0;							// Running net position (based solely on changes to openLedger)
int shiftOpen;									// used for readability 
int shiftHigh;
int shiftLow;
int shiftClose;

void mexFunction(int nlhs, mxArray *plhs[], /* Output variables */
				 int nrhs, const mxArray *prhs[]) /* Input variables */
{
	// There are a number of provided functions for interfacing back to Matlab
	// mexFuncion		The gateway to C.  Required in every C & C++ solution to allow Matlab to call it
	// mexEvalString	Execute Matlab command
	// mexCallMatlab	Call Matlab function (.m or .dll) or script
	// mexPrintf		Print to the Matlab command window
	// mexErrMsgTxt		Issue error message and exit returning control to Matlab
	// mexWarnMsgTxt	Issue warning message
	// mexPrintf("Hello, world!");

	// Check number of inputs
	if (nrhs != 5)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:NumInputs",
		"Number of input arguments is not correct. Aborting.");
	// Check number of output assignments
	if (nlhs != 2)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:NumOutputs",
		"Number of output assignments is not correct. Aborting.");

	// Define constants (#define assigns a variable as either a constant or a macro)
	// Inputs
#define bars_IN		prhs[0]
#define sig_IN		prhs[1]
#define minTick_IN	prhs[2]
#define numTicks_IN	prhs[3]
#define openAvg_IN	prhs[4]
	// Outputs
#define bars_OUT	plhs[0]
#define sig_OUT		plhs[1]

	// Init variables
	mwSize rowsPrice, colsPrice, rowsSig, colsSig;
	double  *barsOutPtr, *sigOutPtr;


	// Check type of supplied inputs
	if (!isReal2DfullDouble(bars_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:BadInputType",
		"Input 'barsIn' must be a 2 dimensional full double array of type Open | High | Low | Close. Aborting.");

	if (!isReal2DfullDouble(sig_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:BadInputType",
		"Input 'sigIn' must be a 2 dimensional full double array. Aborting.");

	if (!isRealScalar(minTick_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:BadInputType",
		"Input 'minTick' must be a single scalar double. Aborting.");

	if (!isRealScalar(numTicks_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:BadInputType",
		"Input 'numTicks' must be a single scalar double. Aborting.");

	if (!isRealScalar(openAvg_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:BadInputType",
		"Input 'openAvg_IN' must be a single scalar double. Aborting.");

	// Assign variables
	rowsPrice = mxGetM(bars_IN);
	colsPrice = mxGetN(bars_IN);
	rowsSig = mxGetM(sig_IN);
	colsSig = mxGetN(sig_IN);
	const double mxLINEAR_SIZE = rowsPrice * colsPrice;					// mxArray is passed as a continuous 1 dimensional array

	//	Assign shift variables
	//	This allows up to properly traverse the mxArray which is in an N x 1 form concatenating all columns
	shiftOpen = 0;							// used for readability 
	shiftHigh = rowsPrice;
	shiftLow = 2 * rowsPrice;
	shiftClose = 3 * rowsPrice;				

	// Additional check of inputs
	if (rowsPrice != rowsSig)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ArrayMismatch",
		"The number of rows in the price array and the signal array are different. Aborting.");

	if (colsSig > 1)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ArrayMismatch",
		"Input 'sigIn' must be a single column array. Aborting.");

	if (!isRealScalar(minTick_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ScalarMismatch",
		"Input 'minTick' must be a double scalar value. Aborting.");

	if (!isRealScalar(numTicks_IN)) 
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ScalarMismatch",
		"Input 'numTicks' must be a double scalar value. Aborting.");

	if (colsPrice != 4)
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ArrayMismatch",
		"Input 'barsIn' must be a 2 dimensional full double array of type Open | High | Low | Close. Aborting.");

	/* Assign pointers to the input arrays */ 
	barsInPtr =		mxGetPr(bars_IN);
	sigInPtr =		mxGetPr(sig_IN);

	/* Assign scalar values */
	minTick =	mxGetScalar(minTick_IN);
	numTicks =	mxGetScalar(numTicks_IN);
	openAvg =	mxGetScalar(openAvg_IN);

	if ((openAvg != 0) && (openAvg != 1))
	{
		mexErrMsgIdAndTxt( "MATLAB:numTicksProfit:ProfitTargetCalc",
			"Input 'openAvg' must be either 0 - atomic price | 1 - average price. \nInput was given as %d. Aborting.", openAvg);
	}

	PROFIT_TGT = (minTick * numTicks);

	// START //
	// Initialize variables
	int	sigIndex;							// Iterator that will store the index of the referenced signal
	int barIndex;							// Iterator that will store the index of the referenced bar
	int anyTrades = 0;						// Variable that indicates if we have any trades

	// Check that we have at least one signal (at least one trade)
	for (sigIndex=0; sigIndex < rowsSig; sigIndex++)					// Remember C++ starts counting at '0'
	{
		if (abs(sigInPtr[sigIndex]) >=1)	// See if we have a signal
		{
			anyTrades=1;					// Trade found
			break;							// Exit the for loop
		}
	}	

	// Either return the input if not trades found, or start the check for profit targets reached per open position
	// We have no trades
	if (anyTrades == 0)						
	{
		// http://www.mathworks.com/support/solutions/en/data/1-6NU359/index.html
		// Return what we were given
		bars_OUT	= mxCreateSharedDataCopy(bars_IN);
		sig_OUT		= mxCreateSharedDataCopy(sig_IN);
	}
	// We have trades
	else									
	{
		/////////////
		//
		// FIRST SIGNAL PROCESSING
		//
		/////////////	
		// sigIndex = first signal index
		// Check for profit on same observation
		sameBarProfitCheck(sigIndex, int(sigInPtr[sigIndex]));

		// Short signal.  Assign minMax to LOW
		if (sigInPtr[sigIndex] < 0)		
		{
			minMax = barsInPtr[sigIndex + 1 + shiftLow];
		}
		// Long signal. Assign minMax to HIGH
		else if (sigInPtr[sigIndex] > 0)	
		{
			minMax = barsInPtr[sigIndex + 1 + shiftHigh];
		}
		// FIRST BAR END

		/////////////
		//
		// ITERATE SECTION
		//
		/////////////

		// ITERATE REMAINING BARS
		// sigIndex = first signal index
		for (int curBar=sigIndex + 1; curBar < rowsSig-1; curBar++)
		{
			// Check observation for signal

			// Fractional signal on observation
			if (fraction(sigInPtr[curBar]))
			{
				// Is there an openPosition to consider ?
				if (openPosition != 0)
				{
					// Is fraction the same sign (additive in nature) ?
					// Additive
					if (sign(sigInPtr[curBar] == sign(openPosition)))
					{
						// Nothing to do with the current logic
						// The only fraction currently in use is |0.5| to liquidate entire opposing openPosition
					}
					// Reductive (liquidate)
					else
					{
						// Adding logic here for prevention of 'other' fractions or surprising inputs
						if (abs((sigInPtr[curBar] - int(sigInPtr[curBar]))) == 0.5)
						{
							// Liquidate any open position
							openLedger.clear();
							openPosition = 0;
						}
						// Unknown advanced instruction
						else
						{
							mexErrMsgIdAndTxt( "MATLAB:AdvancedSignal:fractionUnknown",
								"A signal contained an advanced fractional instruction that we could not interpret. Aborting.");
						}
					}
				}
			}

			// Do we have a signal with an integer portion ?
			if (abs(int(sigInPtr[curBar])) >= 1)
			{
				// Signal is additive
				if ((sigInPtr[curBar] < 0 && openPosition <= 0) || (sigInPtr[curBar] > 0 && openPosition >= 0))					
				{

					sameBarProfitCheck(curBar, int(sigInPtr[curBar]));	
				}
				// Signal is reductive
				else 
				{
					openPosition = openPosition + int(sigInPtr[curBar]);
				}
			}

			// Check for extremes that result in a profit for any openPosition
			if (openPosition != 0)
			{
				checkMinMax(curBar);
			}
		}


		/////////////
		//
		// OUTPUT PROCESSING
		//
		/////////////
		if (!profitLedger.empty())
		{
			shrinkProfitLedger();
			int numNewObsv = profitLedger.size();				// number of new signals and virtual profit bars to add

			/* Create matrices for the return arguments */ 
			// http://www.mathworks.com/help/matlab/matlab_external/c-c-source-mex-files.html
			// http://www.mathworks.com/help/matlab/apiref/mxcreatedoublematrix.html
			mwSize numNewRows = rowsPrice + (mwSize)numNewObsv;

			bars_OUT = mxCreateDoubleMatrix(numNewRows, 4, mxREAL);
			sig_OUT = mxCreateDoubleMatrix(numNewRows, 1, mxREAL);

			// assign the variables for manipulating the arrays (by pointer reference)
			barsOutPtr = mxGetPr(bars_OUT);
			sigOutPtr = mxGetPr(sig_OUT);

			// Temporary lists
			list<double> signals;
			list<double> vBars;

			// List iterators
			list<double>::const_iterator signalsIter		= signals.begin();
			list<double>::const_iterator vBarsIter			= vBars.begin();
			list<double>::const_iterator vBarsOpenIter		= vBars.begin();
			list<double>::const_iterator vBarsHighIter		= vBars.begin();
			list<double>::const_iterator vBarsLowIter		= vBars.begin();
			list<double>::const_iterator vBarsCloseIter		= vBars.begin();

			// Preposition pointers
			advance(vBarsHighIter, shiftHigh);
			advance(vBarsLowIter, shiftLow);
			advance(vBarsCloseIter, shiftClose);

			// deep copy mxArray --> myDblList
			for (int iter = 0; iter < mxLINEAR_SIZE; iter++)
			{
				vBars.push_back(barsInPtr[iter]);
			}

			for (int iter = 0; iter < rowsSig; iter++)
			{
				signals.push_back(sigInPtr[iter]);
			}

			// Inserts based on profitLedger
			list<profitEntry>::iterator pftIter;
			int shiftAdd = 0;
			int lastLoc = 0;

			// Reset pointers
			signalsIter		= signals.begin();
			vBarsOpenIter	= vBars.begin();
			vBarsHighIter	= vBars.begin();
			vBarsLowIter	= vBars.begin();
			vBarsCloseIter	= vBars.begin();

			advance(vBarsHighIter, shiftHigh);
			advance(vBarsLowIter, shiftLow);
			advance(vBarsCloseIter, shiftClose);

			// Move price pointer to sync with signal pointer (signal lags price by one bar)
			vBarsOpenIter++;
			vBarsHighIter++;
			vBarsLowIter++;
			vBarsCloseIter++;

			// At this point we should have pointers as
			// signals[0]
			// vBarsOpenIter[1]
			// vBarsHighIter[1 + shiftHigh] ...

			// Because we insert before the current index we move all pointers 'in front' of the insertion point
			signalsIter++;
			vBarsOpenIter++;
			vBarsHighIter++;
			vBarsLowIter++;
			vBarsCloseIter++;

			while (!profitLedger.empty())
			{
				pftIter = profitLedger.begin();

				shiftAdd = pftIter->barIndex - lastLoc;

				// Advance the pointers to insert location
				advance(signalsIter, shiftAdd);
				advance(vBarsOpenIter, shiftAdd);
				advance(vBarsHighIter, shiftAdd);
				advance(vBarsLowIter, shiftAdd);
				advance(vBarsCloseIter, shiftAdd);

				signals.insert(signalsIter, pftIter->qtyProfit);
				vBars.insert (vBarsOpenIter,pftIter->profitPrice);
				vBars.insert (vBarsHighIter,pftIter->profitPrice);
				vBars.insert (vBarsLowIter,pftIter->profitPrice);
				vBars.insert (vBarsCloseIter,pftIter->profitPrice);

				lastLoc = pftIter->barIndex;

				profitLedger.pop_front();
			}

			// Reset pointer
			int outIter = 0;

			for (vBarsIter	= vBars.begin(); vBarsIter != vBars.end(); vBarsIter++)
			{
				barsOutPtr[outIter] = *vBarsIter;
				outIter++;
			}

			// Reset index
			outIter = 0;
			for (signalsIter = signals.begin(); signalsIter != signals.end(); signalsIter++)
			{
				sigOutPtr[outIter] = *signalsIter;
				outIter++;
			}
		}
		else // return inputs
		{
			// http://www.mathworks.com/support/solutions/en/data/1-6NU359/index.html
			// Return what we were given

			bars_OUT = mxCreateSharedDataCopy(bars_IN);
			sig_OUT = mxCreateSharedDataCopy(sig_IN);
		}
	}

	return;
}

/////////////
//
// METHODS
//
/////////////

// Constructor for ledger line item creation
openEntry createOpenLedgerEntry(int ID, int qty, double price)
{
	openEntry OpenLedgerEntry;
	OpenLedgerEntry.sigIndex = ID;
	OpenLedgerEntry.qtyOpen = qty;
	OpenLedgerEntry.openPrice = price;
	if (qty < 0)
	{
		OpenLedgerEntry.profitPrice = price - (minTick * numTicks);
	}
	else
	{
		OpenLedgerEntry.profitPrice = price + (minTick * numTicks);
	}

	return OpenLedgerEntry;
}

profitEntry createProfitLedgerEntry(int ID, int qty, double price)
{
	profitEntry ProfitLedgerEntry;
	ProfitLedgerEntry.barIndex = ID;
	ProfitLedgerEntry.qtyProfit = qty * -1;		// Reverse the given signal to offset position
	ProfitLedgerEntry.profitPrice = price;

	return ProfitLedgerEntry;
}

void moveProfitLedger(int ID, int qty, double price)
{
	// We take the price of the next observation for the generated signal
	profitLedger.push_back(createProfitLedgerEntry(ID, qty, price));	

	// Should only reduce an openPosition if one exists
	// sameBarProfitCheck may move an entry directly to profitLedger without
	// the value of openPosition being modified
	if (openPosition != 0) 
	{
		openPosition = openPosition - qty;
	}
}

void moveOpenLedger(int ID, int qty)
{
	// We take the price of the next observation for the generated signal
	openLedger.push_back(createOpenLedgerEntry(ID, qty, barsInPtr[ID + 1 + shiftOpen]));
	openPosition = openPosition + qty;
}

// sameBarProfitCheck uses the Signal index and will look at the corresponding
// 'next' observation for price data.
void sameBarProfitCheck(int ID, int qty)
{
	if (openAvg == 0)
	{
		// Is there a profit on the bar of the trade? 
		// Short signal - check LOW
		if ((qty < 0) && (barsInPtr[ID + 1 + shiftLow] < barsInPtr[ID + 1 + shiftOpen] - PROFIT_TGT))
		{
			// We have a profit on the same observation.  Put an entry in the profit ledger
			moveProfitLedger(ID, qty, barsInPtr[ID + 1 + shiftOpen] - PROFIT_TGT);
		}
		// Long signal - check HIGH
		else if ((qty > 0) && (barsInPtr[ID + 1 + shiftHigh] > barsInPtr[ID + 1 + shiftOpen] + PROFIT_TGT))	
		{
			// We have a profit on the same observation.  Put an entry in the profit ledger
			moveProfitLedger(ID, qty, barsInPtr[ID + 1 + shiftOpen] + PROFIT_TGT);		
		} 
		// Signal is not liquidated on same bar. Move it to the open ledger.
		else
		{
			// Put trade on openLedger with calculated profit price
			moveOpenLedger(ID, qty);
			newMinMax(ID);
		}
	}
	else
	{
		// Put trade on openLedger with calculated profit price
		// This can be done in a seemingly 'reverse' order because the impact of the new entry must be calculated
		// It is not considered a 'one-off' or individual trade unless it is the only position.

		moveOpenLedger(ID, qty);

		minMax = barsInPtr[ID + 1 + shiftOpen];

		newMinMax(ID);

	}
}

void newMinMax(int ID)
{
	// Short.  Update minMax to new lower price
	if (openPosition < 0)						
	{
		minMax = barsInPtr[ID + 1 + shiftLow];
	}
	// Long.  Update minMax to new high price
	else if (openPosition > 0)					
	{
		minMax = barsInPtr[ID + 1 + shiftHigh];
	}

	if (!openLedger.empty())
	{
		if (openAvg == 0)
		{
			list<openEntry>::iterator iter;
			for (iter = openLedger.begin(); iter != openLedger.end(); iter++)
			{
				// Short. Check minMax <= profitPrice
				if (openPosition < 0)				
				{
					if (minMax <= iter->profitPrice)
					{
						if (barsInPtr[ID + 1 + shiftOpen] <= iter->profitPrice)
						{
							// Open satisfies profit threshold
							moveProfitLedger(ID, iter->qtyOpen, barsInPtr[ID + 1 + shiftOpen]);
						}
						else
						{
							moveProfitLedger(ID, iter->qtyOpen, iter->profitPrice);
						}
						openLedger.erase(iter);
					}
				}
				// Long. Check minMax >= profitPrice
				else if (openPosition > 0)		
				{
					if (minMax >= iter->profitPrice)
					{
						if (barsInPtr[ID + 1 + shiftOpen] >= iter->profitPrice)
						{
							// Open satisfies profit threshold
							moveProfitLedger(ID, iter->qtyOpen, barsInPtr[ID + 1 + shiftOpen]);
						}
						else
						{
							moveProfitLedger(ID, iter->qtyOpen, iter->profitPrice);
						}
						openLedger.erase(iter);
					}
				}
			}
		}
		// Using the average price approach 
		else
		{
			newAvgChk(ID);
		}
	}
}

void newAvgChk(int ID)
{
	double profitPrice = getAvgPftPrice();

	if (openPosition < 0)				// Short. Check minMax <= profitPrice
	{
		if (minMax <= profitPrice)
		{
			if (barsInPtr[ID + 1 + shiftOpen] <= profitPrice)
			{
				// Open satisfies profit threshold
				moveProfitLedger(ID, openPosition, barsInPtr[ID + 1 + shiftOpen]);
			}
			else
			{
				moveProfitLedger(ID, openPosition, profitPrice);
			}
			openLedger.clear();
			openPosition = 0;
		}
	}
	else if (openPosition > 0)			// Long. Check minMax >= profitPrice
	{
		if (minMax >= profitPrice)
		{
			if (barsInPtr[ID + 1 + shiftOpen] >= profitPrice)
			{
				// Open satisfies profit threshold
				moveProfitLedger(ID, openPosition, barsInPtr[ID + 1 + shiftOpen]);
			}
			else
			{
				moveProfitLedger(ID, openPosition, profitPrice);
			}
			openLedger.clear();
			openPosition = 0;
		}
	}
}

double getAvgPftPrice()
{
	int netQty = 0;
	double wghtPrices = 0;
	double sumWghts = 0;
	double wghtAvg = 0;
	double profitPrice = 0;


	list<openEntry>::iterator iter;
	for (iter = openLedger.begin(); iter != openLedger.end(); iter++)
	{
		netQty = netQty + iter->qtyOpen;
		sumWghts = sumWghts + (abs(iter->qtyOpen) * iter->openPrice);
	}

	wghtAvg = sumWghts / abs(netQty);

	// Short objective
	if (openPosition < 0)
	{
		profitPrice = wghtAvg - PROFIT_TGT;
	}
	// Long objective
	else
	{
		profitPrice = wghtAvg + PROFIT_TGT;
	}

	return profitPrice;
}

void checkMinMax(int ID)
{
	if (openPosition < 0)								// Short.  Check minMax to LOW
	{
		if (barsInPtr[ID + 1 + shiftLow] < minMax)		//New minMax
		{
			newMinMax(ID);
		}
	}
	else if (openPosition > 0)							// Long.  Check minMax to HIGH
	{
		if (barsInPtr[ID + 1 + shiftHigh] > minMax)		//New minMax
		{
			newMinMax(ID);
		}			
	}
}

void shrinkProfitLedger()
{
	list<profitEntry>::iterator iterMain, iterPlusOne;

	iterPlusOne = profitLedger.begin();		// Instantiate look ahead iterator first

	for (iterMain = profitLedger.begin(); iterMain != profitLedger.end(); iterMain++)
	{
		++iterPlusOne;						// Advance the look ahead pointer so it is always iterMain+1;
		if ((iterMain->barIndex == iterPlusOne->barIndex) &&
			(sign(iterMain->qtyProfit) == sign(iterPlusOne->qtyProfit)))
		{
			iterPlusOne->qtyProfit = iterPlusOne->qtyProfit + iterMain->qtyProfit;
			profitLedger.erase(iterMain);
		}
	}
}

// Get sign of signal
double sign(double num)
{
	return num > 0 ? 1 : (num < 0 ? -1 : 0);
}

bool fraction(double num)
{
	if (int(num) == num)
	{
		return false;
	}
	return true;
}

//
//  -------------------------------------------------------------------------
//                                  _    _ 
//         ___  _ __   ___ _ __    / \  | | __ _  ___   ___  _ __ __ _ 
//        / _ \| '_ \ / _ \ '_ \  / _ \ | |/ _` |/ _ \ / _ \| '__/ _` |
//       | (_) | |_) |  __/ | | |/ ___ \| | (_| | (_) | (_) | | | (_| |
//        \___/| .__/ \___|_| |_/_/   \_\_|\__, |\___(_)___/|_|  \__, |
//             |_|                         |___/                 |___/
//  -------------------------------------------------------------------------
//        This code is distributed in the hope that it will be useful,
//
//                      	   WITHOUT ANY WARRANTY
//
//                  WITHOUT CLAIM AS TO MERCHANTABILITY
//
//                  OR FITNESS FOR A PARTICULAR PURPOSE
//
//                          expressed or implied.
//
//   Use of this code, pseudocode, algorithmic or trading logic contained
//   herein, whether sound or faulty for any purpose is the sole
//   responsibility of the USER. Any such use of these algorithms, coding
//   logic or concepts in whole or in part carry no covenant of correctness
//   or recommended usage from the AUTHOR or any of the possible
//   contributors listed or unlisted, known or unknown.
//
//   Any reference of this code or to this code including any variants from
//   this code, or any other credits due this AUTHOR from this code shall be
//   clearly and unambiguously cited and evident during any use, whether in
//   whole or in part.
//
//   The public sharing of this code does not relinquish, reduce, restrict or
//   encumber any rights the AUTHOR has in respect to claims of intellectual
//   property.
//
//   IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY
//   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
//   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//   ANY WAY OUT OF THE USE OF THIS SOFTWARE, CODE, OR CODE FRAGMENT(S), EVEN
//   IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//   -------------------------------------------------------------------------
//
//                             ALL RIGHTS RESERVED
//
//   -------------------------------------------------------------------------
//
//   Author:	Mark Tompkins
//   Revision:	4912.13718
//   Copyright:	(c)2013
//